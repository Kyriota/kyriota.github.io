<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Compute Shader and Boid | KYRIOTA</title>
  <meta name="author" content="KYRIOTA">
  
  <meta name="description" content="最近刷油管看到一个关于生物群模拟的Unity小项目，其中提到了使用ComputeShader来实现多线程的并行计算，感觉很适合入门，就做了一些尝试和改良">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Compute Shader and Boid"/>
  <meta property="og:site_name" content="KYRIOTA"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/img/icon.ico" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="KYRIOTA" type="application/atom+xml">
</head>

 <body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Home</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the blogs.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="Sort by categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About Kyriota">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/html/meme" title="Ingredients that compose me">
			  <i class=""></i>Meme
			</a>
		  </li>
		  
		  <li>
			<a href="/friends" title="Friendship is magic">
			  <i class=""></i>Friends
			</a>
		  </li>
		  
		  <li>
			<a href="/html/academic" title="Academic Home">
			  <i class=""></i>Academic
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Compute Shader and Boid</h1>
		</div>
	



    <div class="row post">
        <!-- cols -->
        
            <div id="top_meta"></div>
            <div class="col-md-9">
                

                            <!-- content -->
                            <div class="mypage">
                                

                                        <p>最近刷油管看到一个关于生物群模拟的Unity小项目，其中提到了使用ComputeShader来实现多线程的并行计算，感觉很适合入门，就做了一些尝试和改良</p>
<p><img src='/images/Boid_Cover.png' style="zoom:50%;" ></p>
<span id="more"></span>
<h1 id="Compute-Shader-and-Boid"><a href="#Compute-Shader-and-Boid" class="headerlink" title="Compute Shader and Boid"></a>Compute Shader and Boid</h1><p><img src="/images/Boid_WholeFinish.png" alt=""></p>
<ul>
<li>首先，什么是<code>ComputeShader</code>？</li>
</ul>
<blockquote>
<p>A <strong>Compute Shader</strong> is a Shader Stage that is used entirely for computing arbitrary information. While it can do rendering, it is generally used for tasks not <em>directly</em> related to drawing triangles and pixels.</p>
</blockquote>
<p>简单地说，就是一个把任务从CPU移到GPU计算的shader就是ComputeShader。关于为什么要这么做，GPU是善于处理高度统一，重复性高的计算的，可以一次性把大量数据写入buffer，然后进行并发的计算，在实际表现中，使用了ComputeShader后的性能提升比纯C#脚本的效率提升了至少两倍</p>
<p>具体说说并发计算，其实也就是多线程，GPU进行多线程计算时，会等到当前buffer中的最后一项操作执行完成后再返回，这就导致类似短板效应的“长板效应”，我的粗略理解为执行一轮计算的时间是需要操作次数最多的一个线程，于是很明显，ComputeShader不能用于分支多，运行时间差异大的算法</p>
<ul>
<li>其次，什么是<code>Boid</code>？</li>
</ul>
<p>对于生物群的模拟，根据 <a target="_blank" rel="noopener" href="http://www.cs.toronto.edu/~dt/siggraph97-course/cwr87/">这篇文章</a>，可以简单把生物群的行为抽象为以下三条</p>
<blockquote>
<ol>
<li>Collision Avoidance: avoid collisions with nearby flockmates</li>
<li>Velocity Matching: attempt to match velocity with nearby flockmates</li>
<li>Flock Centering: attempt to stay close to nearby flockmates</li>
</ol>
</blockquote>
<p>也就是：避免碰撞，速度匹配，位置居中。还有不同的抽象方法，越细致的规则能塑造的群体必然也会越复杂，但其实只要应用了这三个规则，就已经很够看了</p>
<hr>
<p>本工程将群落明确为鱼群，接下来将会从鱼群的抽象规则进行小规模模拟，到应用ComputeShader模拟大规模鱼群，最后使用ShaderGraph制作鱼的摆动以及水面来完善整个工程，为其润色</p>
<blockquote>
<p>其实当真的敲代码的时候会发现约束鱼群的规则都非常简单，但是多个个体所组成的系统确实复杂的</p>
</blockquote>
<h2 id="Getting-Start"><a href="#Getting-Start" class="headerlink" title="Getting Start"></a>Getting Start</h2><p>因为我自己也是Unity入门，对于里面的Rigibody之类的内置力学系统不太了解，也不知道通常的处理这类力学问题的解决方案，恰好我手上拿到的油管dalao的示例代码用的是公式法，即将速度，加速度都保存在变量里，我就照搬他的做法了</p>
<p>为了后期的调参便利（调参真的是一个很麻烦的事情），我将根据三条规则所产生的加速度捆绑为一种类型的加速度，再将规避障碍物的加速度捆绑为另一种加速度，然后对每种类型的加速度分别进行更细致的权重分配</p>
<p>为了便于管理鱼群的行为，将 处理当前的鱼与其他剩余的鱼的代码 与 鱼自身Update的代码 分开编辑是很重要的，不管是编辑的便利还是运行的效率，每次查找其他鱼的时候都<code>FindObjectsOfType&lt;Boid&gt;()</code>一个新的列表是完全没有必要的，所以把这部分与其他鱼产生联系的代码抽象为一个<code>BoidManager</code>类，把更新自身速度等信息的代码放在<code>Boid</code>自己的类里面作为成员才是合理的</p>
<ul>
<li><p>关键函数：</p>
<p>  <code>FindObjectsOfType&lt;Boid&gt;()</code>  按类查找</p>
<p>  <code>Awake()</code> 与 <code>Start()</code>  注意<code>Awake</code>方法比<code>Start</code>先执行就行</p>
</li>
</ul>
<p><img src="/images/Boid_UnityLifeCircle.webp" alt="Boid_UnityLifeCircle" style="zoom: 80%;" /></p>
<h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><h3 id="Collision-Avoidance"><a href="#Collision-Avoidance" class="headerlink" title="Collision Avoidance"></a>Collision Avoidance</h3><p>当前对象与每条鱼位置向量之差即为偏移量，用偏移量的单位向量除以偏移量的模以获得一个基于位置远近的加速度即可</p>
<center><code>avoidAcceleration -= posOffest.normalized / posOffset.magnitude</code></center>

<h3 id="Velocity-Matching"><a href="#Velocity-Matching" class="headerlink" title="Velocity Matching"></a>Velocity Matching</h3><p>当前对象与每条鱼朝向向量之差即为偏移量，因为其实实际运行中速度的大小差异不会很大，速度方向却会有很大差异，所以只用匹配一下朝向即可</p>
<center><code>headingAcceleration += forwardOffest</code></center>

<h3 id="Flock-Centering"><a href="#Flock-Centering" class="headerlink" title="Flock Centering"></a>Flock Centering</h3><p>这其实就是第一条规则去掉距离远近的加权</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> anoBoidIndex = <span class="number">0</span>; anoBoidIndex &lt; boids.Length; anoBoidIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (boidIndex != anoBoidIndex) &#123;</span><br><span class="line">        Vector3 offest = boids[boidIndex].transform.position - boids[anoBoidIndex].transform.position;</span><br><span class="line">        <span class="built_in">float</span> sqrDis = offest.sqrMagnitude;</span><br><span class="line">        <span class="keyword">if</span> (sqrDis &lt; viewRadius * viewRadius) &#123;</span><br><span class="line">            headingAcceleration += boids[anoBoidIndex].transform.forward - boids[boidIndex].transform.forward;</span><br><span class="line">            centerAcceleration -= offest;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sqrDis &lt; avoidRadius * avoidRadius) avoidAcceleration += offest.normalized / sqrDis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">boids[boidIndex].acceleration = avoidAcceleration * avoidWeight + headingAcceleration * headingWeight + centerAcceleration * centerWeight;</span><br></pre></td></tr></table></figure>
<p>其中引入了几个Radius作为是否影响当对象的阈值以限制鱼的视力范围</p>
<p>应用了三个规则后可以如下GIF的效果</p>
<p><img src="/images/Boid_Rules.gif" alt=""></p>
<center><small>（红色的那条是0号鱼(初号机)，为的是便于从个体的视角观察动向）</small></center>

<p>我在一个圆内在随机的位置以随机的朝向生成了一些鱼，不难发现他们很快就会根据自己的位置与朝向形成几个鱼群，但这些鱼群都十分稳定，这是因为虽然他们受群聚规则的限制，但没有一个外力来破坏这一规则限制出的稳定结构，我们想看到的必然不是一个稳定结构的鱼群</p>
<p>对于外力，我们可以选择增加一个驱逐者来追赶鱼群，类似于 <a href="www.bilibili.com/video/BV1tq4y1j7TW">这个视频</a>，也可以增加障碍物来阻挡鱼群，在此为了场景的多样性，我选择后者</p>
<h2 id="Obstacle-Avoidance"><a href="#Obstacle-Avoidance" class="headerlink" title="Obstacle Avoidance"></a>Obstacle Avoidance</h2><p>其实上述的鱼群行动规则非常简单，不管是字面上看起来还是代码上敲起来，这也使得在空旷环境中的鱼群看起来很没意思，所以加入一个避障的function来使它更有趣吧</p>
<p>要使鱼避开前方的障碍物，首先想到的便是<code>Physics.Raycast()</code>射线检测，但此函数对CPU貌似不怎么友好，大量运行此函数卡成PPT，而单个的射线检测也是检测到物体时就返回了，均具有执行时间具有高度不确定性的特征，不适宜使用ComputeShader来提速，故唯一的解决方案就是尽可能地减少射线数量</p>
<p>在示例工程中，这位老哥使用了 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere/44164075#44164075">这种方法</a> 来使点阵在球面上近似均匀分布，然后对每个点做射线检测，大致是对黄金螺线做极径开个根号，使得螺线上的点均匀摊开，BEAUTIFUL</p>
<p><img src="/images/Boid_DIvideSphere1.png" alt=""></p>
<p>而从圆面到球面，把极径换成φ就过来了</p>
<p><img src="/images/Boid_DIvideSphere2.png" alt=""></p>
<p>表达可能不太清楚，但只要动手调一下参，模拟一下螺线的变化就很明白了</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> numDivide = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">float</span> viewAngleRatio = <span class="number">4f</span> / <span class="number">5f</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Vector3[] viewVec3;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> numViewDirections = Mathf.CeilToInt(numDivide * viewAngleRatio);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BoidHelper</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    viewVec3 = <span class="keyword">new</span> Vector3[BoidHelper.numDivide];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> goldenRatio = (<span class="number">1</span> + Mathf.Sqrt(<span class="number">5</span>)) / <span class="number">2f</span>;</span><br><span class="line">    <span class="built_in">float</span> angleIncrement = Mathf.PI * <span class="number">2</span> * goldenRatio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numViewDirections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> t = (<span class="built_in">float</span>)i / numDivide;</span><br><span class="line">        <span class="built_in">float</span> inclination = Mathf.Acos(<span class="number">1</span> - <span class="number">2</span> * t);</span><br><span class="line">        <span class="built_in">float</span> azimuth = angleIncrement * i;</span><br><span class="line"></span><br><span class="line">        viewVec3[i].x = Mathf.Sin(inclination) * Mathf.Cos(azimuth);</span><br><span class="line">        viewVec3[i].y = Mathf.Sin(inclination) * Mathf.Sin(azimuth);</span><br><span class="line">        viewVec3[i].z = Mathf.Cos(inclination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例工程中这位老哥应该也是怕射线太多导致卡顿，方案比较暴力，就是从前方开始检测，一旦检测到空旷处就直接加个距离的权重然后应用到加速度上并直接<code>break</code>掉循环了，也就是说鱼会朝着第一个检测到的空旷处游去。</p>
<p><img src="/images/Boid_Close2Ground.png" alt=""></p>
<p>这不免导致了一个问题，那就是鱼最后会和障碍物表面相切，然后贴着障碍物表面移动，先不说这样会导致在下一次受到扰动时穿模的问题，这种款式的鱼群简直像极了一群大耗子</p>
<p><img src="/images/Boid_StickToGround.gif" alt=""></p>
<p>所以既然在场景不会很复杂的时候使用这么多射线属实没有必要，经过实际测试，使用几条射线分辨侧面环境并且不<code>break</code>射线检测的循环，使鱼充分认知到周围环境，将此与上述等分检测的方法组合便是一个更优解，此处我选择的是12条射线，即xy平面上60°等分，再在φ=45°的圆周上也60°等分</p>
<p><img src="/images/Boid_Close2GroundFix.png" alt=""></p>
<p>避障的相关代码因为不涉及其他鱼，选择把代码放在了<code>Boid</code>类下，但这会导致调参的时候需要在Unity中频繁切换Inspector，解决方案是把参数全部放到一个<code>Setting</code>类中，此类继承<code>ScriptableObject</code>，这样不仅解决了Inspector的问题，还使得Prefab在被拷贝时通过reference访问数据，避免了多次拷贝造成的内存浪费，也提升了在运行中调参时的整体性，运行中进行的调参也得以直接保存而不用Copy Component Values了</p>
<h3 id="Front"><a href="#Front" class="headerlink" title="Front"></a>Front</h3><p>在进行正面避障时，如果提供的射线少了则会使得鱼的速度方向变化过大，不够平滑，所以正面避障直接采用黄金螺旋法在球面上等距取点，从正面开始遍历这些点，一旦取到一个可转向的范围就<code>break</code>即可</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">AvoidObstacleDir</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; BoidHelper.numViewDirections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 viewDir = transform.TransformDirection(BoidHelper.viewVec3[i]);</span><br><span class="line">        Ray ray = <span class="keyword">new</span> Ray(transform.position, viewDir);</span><br><span class="line">        <span class="keyword">if</span> (!Physics.Raycast(ray, obstacleRadius, obstacleMask)) <span class="keyword">return</span> viewDir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Vector3.zero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Around"><a href="#Around" class="headerlink" title="Around"></a>Around</h3><p>示例工程中因为缺少了对周围障碍物的检测，导致了大量因为贴近物体表面移动而穿过Collider的行为，所以在周围加入少量的<code>Raycast</code>，使得鱼也不会过于靠近四周的障碍</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">KeepDstWithObstDir</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Vector3 keepDstDir = Vector3.zero;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; circleFrac; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 viewDir = Vector3.zero;</span><br><span class="line">        <span class="built_in">float</span> angle = i / (<span class="built_in">float</span>)circleFrac * <span class="number">2</span> *Mathf.PI;</span><br><span class="line">        viewDir.x = Mathf.Sin(angle);</span><br><span class="line">        viewDir.y = Mathf.Cos(angle);</span><br><span class="line">        viewDir = transform.TransformDirection(viewDir);</span><br><span class="line">        Ray ray = <span class="keyword">new</span> Ray(transform.position, viewDir);</span><br><span class="line">        RaycastHit hit;</span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(ray,<span class="keyword">out</span> hit, keepDstWithObstRadius, obstacleMask)) keepDstDir -= viewDir / hit.distance;</span><br><span class="line">        <span class="comment">// cos(PI/4) is close to 0.7071</span></span><br><span class="line">        <span class="built_in">float</span> angleOffset = <span class="number">1</span> / (<span class="built_in">float</span>)circleFrac * Mathf.PI;</span><br><span class="line">        viewDir.x = Mathf.Sin(angle + angleOffset) * <span class="number">0.7071f</span>;</span><br><span class="line">        viewDir.y = Mathf.Cos(angle + angleOffset) * <span class="number">0.7071f</span>;</span><br><span class="line">        viewDir.z = <span class="number">0.7071f</span>;</span><br><span class="line">        viewDir = transform.TransformDirection(viewDir);</span><br><span class="line">        ray = <span class="keyword">new</span> Ray(transform.position, viewDir);</span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(ray,<span class="keyword">out</span> hit, keepDstWithObstRadius, obstacleMask)) keepDstDir -= viewDir / hit.distance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keepDstDir.normalized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>至此鱼群的模拟已经基本完成，接下来要做的便是将<code>Rules</code>部分的代码移植到ComputeShader中计算，以减轻CPU的负担</p>
<p><img src="/images/Boid_BasicResult.gif" alt=""></p>
<p>除了使用障碍物破坏鱼群的稳定结构，加入捕食者、食物之类的机制也可以为鱼群系统增添复杂性与趣味性，不妨自己尝试一下</p>
<h2 id="Compute-Shader"><a href="#Compute-Shader" class="headerlink" title="Compute Shader"></a>Compute Shader</h2><h3 id="WTF-is-this"><a href="#WTF-is-this" class="headerlink" title="WTF is this"></a>WTF is this</h3><p>不妨使用文档中的示例来解释一下ComputeShader，下面这个ComputeShader将一个材质涂红</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#pragma kernel FillWithRed</span><br><span class="line">RWTexture2D&lt;float4&gt; res;</span><br><span class="line">[numthreads(1,1,1)]</span><br><span class="line">void FillWithRed (uint3 dtid : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    res[dtid.xy] &#x3D; float4(1,0,0,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见ComputeShader使用<code>HLSL</code>语言，也就是<code>High Level Shader Language</code>，因为通常只是拿来做数学计算，所以基本上只要装一个hlsl的代码提示的extension就可以直接开始写了</p>
<p><code>#pragma kernel FillWithRed</code>：首先定义了一个核函数，函数名默认是CSMain，这是compute shader的函数入口，你也可以定义多个入口，因为本工程只需要一个入口，多个入口的ComputeShader暂时没有多做了解</p>
<p><code>[numthreads(1,1,1)]</code>：规定了使用的线程组大小，这里使用的是单线程，默认是<code>(8,8,1)</code>，线程数量为<code>8x8x1</code>，也就是64线程作为一个线程组。<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38884324/article/details/80570160">更多地了解numthreads</a> 会发现里面东西挺多，涉及到显卡的硬件</p>
<p><img src="/images/Boid_ThreadGroup.png" alt="Boid_ThreadGroup" style="zoom:50%;" /></p>
<p>如上图，<code>numthreads</code>规定了一个Group(线程组)中的线程数量，<code>Dispatch()</code>作为C#脚本调用ComputeShader的交互方式，与<code>numthread</code>有一些联系，在介绍完Unity的官方ComputeShader示例后会提到。至于为什么大小由一个三维数组确定，是为了在访问2D或者3D的数据结构的时候更加方便操作(大概是吧)</p>
<blockquote>
<p>The ability to specify the size of the thread group across three dimensions allows individual threads to be accessed in a manner that logically 2D and 3D data structures</p>
<p align="right"><a herf="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-attributes-numthreads">--Microsoft Doc</a></p>

</blockquote>
<p>在实际使用中，一般不会使<code>numthreads</code>小于32，这会达不到最低线程数导致多核围观；但也不能超过1024，应该也是硬件层面的限制。根据之前提到的CSDN上的建议：</p>
<blockquote>
<p>AMD：ThreadSize 使用 64 的倍數 ( wavefront 架構 )<br>NVIDIA：ThreadSize 使用 32 的倍數 ( SIMD32 (Warp) 架構 )</p>
</blockquote>
<p>这么一看官方初始线程数选择64还挺合理的，但我们仍然需要根据自己的实际需求以及预期的线程组数来选择具体的<code>numthread</code></p>
<p><code>ID</code>：在声明方法时提到了<code>ID</code>的概念，即<code>void FillWithRed (uint3 dtid : SV_DispatchThreadID)</code>中的<code>SV_DispatchThreadID</code>，其实这些三维的<code>ID</code>基本上就是<code>index</code>了</p>
<blockquote>
<p>SV_GroupID : 線程組 ID<br>SV_GroupThreadID : 線程組內的線程 ID (三維，你可以理解為 Group 內的座標)<br>SV_GroupIndex : 線程組內的線程 ID (一維)<br>SV_DispatchThreadID : 唯一ID (你可以理解成整張圖片座標)</p>
</blockquote>
<p><img src="/images/Boid_ID.png" alt="Boid_ID" style="zoom:50%;" /></p>
<p><code>Dispatch(kernelIndex,x,y,z)</code>：用于在C#脚本中调用ComputeShader，第一个参数为核函数的index，如果是CSMain就直接是0，如果不确定index到底是多少，可以通过<code>FindeKernel(String kernelName)</code>获取index。关于后面的xyz，需要满足<code>Dispatch*numthread&gt;=numData</code>，否则既然你的输入都不全，怎么获得一个完整的输出呢？</p>
<p>举几个栗子：</p>
<ul>
<li><p>Eg1.输出ComputeShader的默认代码</p>
<p>  ComputeShader在Unity中创建时初始化代码如下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Each #kernel tells which function to compile; you can have many kernels</span><br><span class="line">#pragma kernel CSMain</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create a RenderTexture with enableRandomWrite flag and set it</span><br><span class="line">&#x2F;&#x2F; with cs.SetTexture</span><br><span class="line">RWTexture2D&lt;float4&gt; Result;</span><br><span class="line"></span><br><span class="line">[numthreads(8,8,1)]</span><br><span class="line">void CSMain (uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: insert actual code here!</span><br><span class="line"></span><br><span class="line">    Result[id.xy] &#x3D; float4(id.x &amp; id.y, (id.x &amp; 15)&#x2F;15.0, (id.y &amp; 15)&#x2F;15.0, 0.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以使用一个C#脚本调用它</p>
  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tester</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ComputeShader cs;</span><br><span class="line">    <span class="keyword">public</span> RenderTexture tex;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个材质查看结果</span></span><br><span class="line">        tex = <span class="keyword">new</span> RenderTexture(<span class="number">256</span>,<span class="number">256</span>,<span class="number">24</span>);</span><br><span class="line">        <span class="comment">// 一定要记得打开写入权限</span></span><br><span class="line">        tex.enableRandomWrite = <span class="literal">true</span>;</span><br><span class="line">        tex.Create();</span><br><span class="line">        <span class="comment">// 在Dispatch前需要先传入参数</span></span><br><span class="line">        cs.SetTexture(<span class="number">0</span>, <span class="string">&quot;Result&quot;</span>, tex);</span><br><span class="line">        <span class="comment">// 注意到numthread为(8,8,1)，有numthread*Dispatch=Resolution</span></span><br><span class="line">        cs.Dispatch(<span class="number">0</span>, <span class="number">256</span>/<span class="number">8</span>, <span class="number">256</span>/<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  得到一个好康的分形图案</p>
<p>  <img src="/images/Boid_CSdefault.png" alt=""></p>
</li>
<li><p>Eg2.将参数改小</p>
<p>  <code>Dispatch(0,64/8,128/8,1);</code></p>
<p>  <code>numthread[8,8,1];</code></p>
<p>  <img src="/images/Boid_CSeg2.png" alt=""></p>
<p>  观察到图像不全且只有64x128，与Dispatch中传入的量吻合</p>
</li>
<li><p>Eg3.将参数改大</p>
<p>  <code>tex = new RenderTexture(256,300,24);</code></p>
<p>  <code>Dispatch(0,256/8,(int)Mathf.Ceil(300/8),1);</code></p>
<p>  <code>numthread[8,8,1];</code></p>
<p>  <img src="/images/Boid_CSeg3.png" alt=""></p>
<p>  注意到<code>(int)Mathf.Ceil(300/8) * 8 &gt; 300</code>，如果此处不用<code>Ceil</code>向上取整则会少一部份没有被计算</p>
</li>
</ul>
<h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p><code>C#</code>翻译到<code>hlsl</code>的工作流程如下</p>
<p>首先是C#脚本上</p>
<ul>
<li><p>创建结构体保存一些属性，其中<code>acceleration</code>作为计算结果，等待在ComputeShader中被赋值</p>
  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> BoidData &#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 position;</span><br><span class="line">    <span class="keyword">public</span> Vector3 forward;</span><br><span class="line">    <span class="keyword">public</span> Vector3 acceleration;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Size &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span> (<span class="built_in">float</span>) * <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  实例化，赋值，创建Buffer</p>
  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boidData = <span class="keyword">new</span> BoidData[boids.Length];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; boids.Length; i++) &#123;</span><br><span class="line">    boidData[i].position = boids[i].transform.position;</span><br><span class="line">    boidData[i].forward = boids[i].transform.forward;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> boidBuffer = <span class="keyword">new</span> ComputeBuffer (boids.Length, BoidData.Size);</span><br><span class="line">boidBuffer.SetData (boidData);</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入ComputeShader计算需要的变量信息</p>
  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computeShader.SetBuffer(<span class="number">0</span>, <span class="string">&quot;boids&quot;</span>, boidBuffer);</span><br><span class="line">computeShader.SetInt(<span class="string">&quot;numBoids&quot;</span>, boids.Length);</span><br><span class="line">computeShader.SetFloat(<span class="string">&quot;viewRadius&quot;</span>, viewRadius);</span><br><span class="line">computeShader.SetFloat(<span class="string">&quot;avoidRadius&quot;</span>, avoidRadius);</span><br><span class="line">computeShader.SetFloat(<span class="string">&quot;avoidWeight&quot;</span>, avoidWeight);</span><br><span class="line">computeShader.SetFloat(<span class="string">&quot;headingWeight&quot;</span>, headingWeight);</span><br><span class="line">computeShader.SetFloat(<span class="string">&quot;centerWeight&quot;</span>, centerWeight);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>Dispatch()</code>开始执行ComputeShader</p>
<p>  <code>computeShader.Dispatch(0, threadGroups, 1, 1);</code></p>
</li>
</ul>
<p>现在把视角切换到ComputeShader上</p>
<ul>
<li><p>把需要传入的变量都定义一遍，这里注意结构体使用了<code>RWStructuredBuffer</code>作为容器</p>
<blockquote>
<p>A structured buffer is a buffer that contains elements of equal sizes. Use a structure with one or more member types to define an element. Here is a structure with three members.</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Boid &#123;</span><br><span class="line">    float3 position;</span><br><span class="line">    float3 forward;</span><br><span class="line">    float3 acceleration;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RWStructuredBuffer&lt;Boid&gt; boids;</span><br><span class="line">int numBoids;</span><br><span class="line">float viewRadius;</span><br><span class="line">float avoidRadius;</span><br><span class="line">float avoidWeight;</span><br><span class="line">float headingWeight;</span><br><span class="line">float centerWeight;</span><br></pre></td></tr></table></figure>
</li>
<li><p>翻译一遍C#代码，只需要改一点语法就可以了</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void CSMain (uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    float3 zero3 &#x3D; &#123;0, 0, 0&#125;;</span><br><span class="line">    float3 avoidAcceleration &#x3D; zero3;</span><br><span class="line">    float3 headingAcceleration &#x3D; zero3;</span><br><span class="line">    float3 centerAcceleration &#x3D; zero3;</span><br><span class="line">    int mateCount;</span><br><span class="line">    int avoidCount;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; numBoids; i ++)&#123;</span><br><span class="line">        if((int)id.x !&#x3D; i)&#123;</span><br><span class="line">            float3 offset &#x3D; boids[id.x].position - boids[i].position;</span><br><span class="line">            float sqrDst &#x3D; offset.x * offset.x + offset.y * offset.y + offset.z * offset.z;</span><br><span class="line">            if(sqrDst &lt; viewRadius * viewRadius)&#123;</span><br><span class="line">                mateCount +&#x3D; 1;</span><br><span class="line">                headingAcceleration +&#x3D; boids[i].forward - boids[id.x].forward;</span><br><span class="line">                centerAcceleration -&#x3D; offset;</span><br><span class="line">            &#125;</span><br><span class="line">            if(sqrDst &lt; avoidRadius * avoidRadius)&#123;</span><br><span class="line">                avoidCount++;</span><br><span class="line">                avoidAcceleration +&#x3D; normalize(offset) &#x2F; sqrDst;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    avoidAcceleration &#x3D; avoidCount &#x3D;&#x3D; 0 ? zero3 : normalize(avoidAcceleration);</span><br><span class="line">    headingAcceleration &#x3D; mateCount &#x3D;&#x3D; 0 ? zero3 : normalize(headingAcceleration);</span><br><span class="line">    centerAcceleration &#x3D; mateCount &#x3D;&#x3D; 0 ? zero3 : normalize(centerAcceleration);</span><br><span class="line">    boids[id.x].acceleration &#x3D; avoidAcceleration * avoidWeight + headingAcceleration * headingWeight + centerAcceleration * centerWeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关于<code>numthread</code>，示例工程直接设了<code>[1024,1,1]</code>：使用一维向量是因为需要处理的数据没有类似材质、体积之类的三维结构体；<code>1024</code>是为了直接把线程拉满</p>
<h3 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h3><p>将原本在CPU中进行的大量重复计算迁移至GPU后可模拟的鱼群规模瞬间提升了不少，现在你可以模拟一些较大规模的鱼群了，在此就不附新的图片了</p>
<h2 id="Polish"><a href="#Polish" class="headerlink" title="Polish"></a>Polish</h2><p>就算为其换上一个真正的鱼🐟的模型，现在的鱼群整体还比较单调，虽然有了一些规则使得其在宏观动态的表现力上有了那么一捏捏，但还缺少一些更加直观的细节，说白了就是有一个有趣的灵魂但没有华丽的外表，所以我们不妨做两个shader来为其润色，一个shader负责鱼的摆动，另一个负责水面材质</p>
<p>我使用的是HDRP作为渲染管线，虽然我不会用它，但我听说他很强，所以我希望能迈出第一步</p>
<p>由于目前使用的是ShaderGraph，不便于附代码，只能讲一下思路并附带一些资料了</p>
<h3 id="Waving-Fish"><a href="#Waving-Fish" class="headerlink" title="Waving Fish"></a>Waving Fish</h3><p>其实可以用一个<code>sin(t)</code>函数就能获得很能接受的效果了，但是鉴于鱼都是成群出现，以时间为变量的函数肯定是不行的，我当前的做法是将鱼的世界坐标作为变量，输入到<code>Gradient Noise</code>，对鱼的顶点坐标的某一个轴向应用这个噪声，这样得到的鱼会根据自身位置而决定摇摆，缺点是没有和鱼的转向、运动等联系起来，在设想中，能根自身加速度选择摇摆方式的Shader才是最好的，但目前不清楚这样做的可行性以及具体方法</p>
<p>接下来还需要将鱼头的摇摆幅度降低，因为一般来说鱼头不会像尾巴和身体那样剧烈摆动。在此推荐了解一下有关<code>UV</code>的概念，这很重要，比如此处可以将UV的x作为变量，在噪声和原本的顶点位置之间做线性插值(LERP)，也可以对UV.x取平方之类的以让摆动的过度更加自然</p>
<p>综上，便得到了一条欢快的小鱼🐟</p>
<p><img src="/images/Boid_WavingFish.gif" alt=""></p>
<h3 id="Water-Surface-Shader"><a href="#Water-Surface-Shader" class="headerlink" title="Water Surface Shader"></a>Water Surface Shader</h3><p>鱼得到了升级，还需要一个容器来使得整个场景在水中，这里选择制作一个水面的材质贴在平面上，做成开头那样的水立方，Unity官方提供了 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=gRq-IdShxpU">基本的水面ShdaerGraph教程</a>，由于处处碰壁，我也就基本是抄了一遍官方的成果</p>
<p>主要的思想是使<code>Scene Depth</code>与<code>Screen Position</code>相减，由于前者的检测不包含透明物体，而后者包含，则可以获取穿过一个透明平面后的空间深度信息</p>
<p><img src="/images/Boid_Depth.png" alt="Boid_Depth" style="zoom: 67%;" /></p>
<p>之后只需要在这个平面的表面做两层不同细节程度的水面Normal Map的反向滚动，再加入由噪声控制的平面顶点坐标的起伏即可</p>
<h2 id="Final-Result"><a href="#Final-Result" class="headerlink" title="Final Result"></a>Final Result</h2><p>Check the final result if you want, a gif about 10 Mb</p>
<p><img src="/images/Boid_Final.gif" alt=""></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
                            </div>

                            <div>
                                <center>
                                    <div class="pagination">

    
    
    <a href="/2021/10/02/AntColonyOptimization/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2021/04/24/RenderHighDimensionalObjectInTerminal/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

                                </center>
                            </div>

                            <!-- comment -->
                            
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>


                    </div>
                    <!-- col-md-9/col-md-12 -->

                    
                        <div id="side_meta">
                            <div class="col-md-3" id="post_meta">

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2021-09-23
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/Unity/">Unity<span>5</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#Compute-Shader-and-Boid"><span class="toc-article-text">Compute Shader and Boid</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Getting-Start"><span class="toc-article-text">Getting Start</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Rules"><span class="toc-article-text">Rules</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Collision-Avoidance"><span class="toc-article-text">Collision Avoidance</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Velocity-Matching"><span class="toc-article-text">Velocity Matching</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Flock-Centering"><span class="toc-article-text">Flock Centering</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Result"><span class="toc-article-text">Result</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Obstacle-Avoidance"><span class="toc-article-text">Obstacle Avoidance</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Front"><span class="toc-article-text">Front</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Around"><span class="toc-article-text">Around</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Result-1"><span class="toc-article-text">Result</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Compute-Shader"><span class="toc-article-text">Compute Shader</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#WTF-is-this"><span class="toc-article-text">WTF is this</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Translation"><span class="toc-article-text">Translation</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Result-2"><span class="toc-article-text">Result</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Polish"><span class="toc-article-text">Polish</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Waving-Fish"><span class="toc-article-text">Waving Fish</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#Water-Surface-Shader"><span class="toc-article-text">Water Surface Shader</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Final-Result"><span class="toc-article-text">Final Result</span></a></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

                        </div>
                        

            </div>
            <!-- row -->
            


                
                    <div id="gitalk-container"></div>
                    <link rel="stylesheet" href="/css/gitalk.css">
<script src="/js/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<script type="text/javascript">
    new Gitalk({
        clientID: '91155bbf0d150664c4e8',
        clientSecret: 'a6ace36b45921480fe64e5a8d76de241d197bb15',
        repo: 'kyriota.github.io',
        owner: 'Kyriota',
        admin: 'Kyriota',
        id: md5(location.pathname),
        createIssueManually: true,
        distractionFreeMode: true
    }).render('gitalk-container')
</script>
                        
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
    
        &copy;
        2023
            KYRIOTA
                
                                Powered By <a href="http://hexo.io/" target="_blank">Hexo</a>, Modified From <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
