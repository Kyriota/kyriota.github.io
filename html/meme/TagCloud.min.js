/*!
 * TagCloud.js v2.3.0
 * Copyright (c) 2016-2022 @ Cong Min
 * MIT License - https://github.com/mcc108/TagCloud
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
      (global = global || self, global.TagCloud = factory());
}(this, (function () {
  'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function sigmoid(e) {
    return 1 / (1 + Math.exp(-e));
  }
  function regularize(value, min, max, coe = 0.95) {
    if (value > max) {
      if (value * coe < max) {
        value = max;
      } else {
        value *= coe;
      }
    }
    if (value < min) {
      if (value * coe > min) {
        value = min;
      } else {
        value *= coe;
      }
    }
    return value;
  }

  /**
   * TagCloud.js (c) 2016-2019 @ Cong Min
   * MIT License - https://github.com/mcc108/TagCloud
   */
  var TagCloud = /*#__PURE__*/function () {
    /* constructor */
    function TagCloud() {
      var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.body;
      var htmls = arguments.length > 1 ? arguments[1] : undefined;
      var options = arguments.length > 2 ? arguments[2] : undefined;

      _classCallCheck(this, TagCloud);

      var self = this;
      if (!container || container.nodeType !== 1) return new Error('Incorrect element type'); // params

      self.$container = container;
      self.htmls = htmls || [];
      self.config = _objectSpread2(_objectSpread2({}, TagCloud._defaultConfig), options || {}); // calculate config

      self.radius = self.config.radius; // rolling radius

      self.depth = 2 * self.radius; // rolling depth

      self.size = 1.5 * self.radius; // rolling area size with mouse

      self.maxSpeed = TagCloud._getMaxSpeed(self.config.maxSpeed); // rolling max speed

      self.initSpeed = TagCloud._getInitSpeed(self.config.initSpeed); // rolling init speed

      self.direction = self.config.direction; // rolling init direction

      self.keep = self.config.keep; // whether to keep rolling after mouse out area

      self.paused = false; // keep state to pause the animation
      // create element

      self._createElement(); // init


      self._init(); // set elements and instances


      TagCloud.list.push({
        el: self.$el,
        container: container,
        instance: self
      });
    }
    /* static method */
    // all TagCloud list


    _createClass(TagCloud, [{
      key: "_createElement",
      value:
        /* instance property method */
        // create elment
        function _createElement() {
          var self = this; // create container

          var $el = document.createElement('div');
          $el.className = self.config.containerClass;

          if (self.config.useContainerInlineStyles) {
            $el.style.position = 'relative';
            $el.style.width = "".concat(2 * self.radius, "px");
            $el.style.height = "".concat(2 * self.radius, "px");
          } // create item elements


          self.items = [];
          self.htmls.forEach(function (htmlCfg, index) {
            var cfg = TagCloud._parseTagCfg(htmlCfg);

            var item = _objectSpread2({
              el: self._createItemElement(cfg.html, index, cfg.mutator)
            }, self._computePosition(index));

            $el.appendChild(item.el);
            self.items.push(item);
          });
          self.$container.appendChild($el);
          self.$el = $el;
        }
    }, {
      key: "_createItemElement",
      value: function _createItemElement(html) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var mutator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var self = this;
        var temp = document.createElement('template');
        console.log(html);
        temp.innerHTML = html.trim();
        var itemEl = temp.content.firstChild;

        if (itemEl.nodeType !== Node.ELEMENT_NODE) {
          itemEl = document.createElement('span');
          itemEl.innerText = temp.content.firstChild.textContent;
        }

        itemEl.className = self.config.itemClass;

        if (self.config.useItemInlineStyles) {
          itemEl.style.willChange = 'transform, opacity, filter';
          itemEl.style.position = 'absolute';
          itemEl.style.top = '50%';
          itemEl.style.left = '50%';
          itemEl.style.zIndex = index + 1;
          itemEl.style.filter = 'alpha(opacity=0)';
          itemEl.style.opacity = 0;
          var transformOrigin = '50% 50%';
          itemEl.style.WebkitTransformOrigin = transformOrigin;
          itemEl.style.MozTransformOrigin = transformOrigin;
          itemEl.style.OTransformOrigin = transformOrigin;
          itemEl.style.transformOrigin = transformOrigin;
          var transform = 'translate3d(-50%, -50%, 0) scale(1)';
          itemEl.style.WebkitTransform = transform;
          itemEl.style.MozTransform = transform;
          itemEl.style.OTransform = transform;
          itemEl.style.transform = transform;
          
          itemEl.style.WebkitUserSelect = 'none'; // make the user can't select the text

          // select img element and set style
          var img_el = itemEl.querySelector('img');
          if (img_el) {
            img_el.style.borderRadius = '50%';
            img_el.style.objectFit = 'cover';
            img_el.draggable = false;
            img_el.style.width = '100px';
            img_el.style.height = '100px';
          }

          // select href element and set style
          var href_el = itemEl.querySelector('a');
          if (href_el) {
            href_el.draggable = false;
          }
        }

        if (typeof mutator === 'function') mutator.call(itemEl);
        return itemEl;
      } // calculate appropriate place

    }, {
      key: "_computePosition",
      value: function _computePosition(index) {
        var random = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var self = this;
        var htmlsLength = self.htmls.length; // if random `true`, It means that a random appropriate place is generated, and the position will be independent of `index`

        if (random) index = Math.floor(Math.random() * (htmlsLength + 1));
        var phi = Math.acos(-1 + (2 * index + 1) / htmlsLength);
        var theta = Math.sqrt((htmlsLength + 1) * Math.PI) * phi;
        return {
          x: self.size * Math.cos(theta) * Math.sin(phi) / 2,
          y: self.size * Math.sin(theta) * Math.sin(phi) / 2,
          z: self.size * Math.cos(phi) / 2
        };
      }
    }, {
      key: "_requestInterval",
      value: function _requestInterval(fn, delay) {
        var requestAnimFrame = (function () {
          return window.requestAnimationFrame;
        } || function (callback, element) {
          window.setTimeout(callback, 1000 / 60);
        })();

        var start = new Date().getTime();
        var handle = {};

        function loop() {
          handle.value = requestAnimFrame(loop);
          var current = new Date().getTime(),
            delta = current - start;

          if (delta >= delay) {
            fn.call();
            start = new Date().getTime();
          }
        }

        handle.value = requestAnimFrame(loop);
        return handle;
      } // init

    }, {
      key: "_init",
      value: function _init() {
        var self = this;
        self.active = false; // whether the mouse is activated

        self.mouseX0 = self.initSpeed * Math.sin(self.direction * (Math.PI / 180)); // init distance between the mouse and rolling center x axis
        self.mouseY0 = -self.initSpeed * Math.cos(self.direction * (Math.PI / 180)); // init distance between the mouse and rolling center y axis

        self.mouseX = self.mouseX0; // current distance between the mouse and rolling center x axis
        self.mouseY = self.mouseY0; // current distance between the mouse and rolling center y axis

        self.delta_mouseX = self.mouseX0;
        self.delta_mouseY = self.mouseY0;

        self.last_mouseX = null; // last distance between the mouse and rolling center x axis
        self.last_mouseY = null; // last distance between the mouse and rolling center y axis

        self.last_a = null; // last a
        self.last_b = null; // last b

        self.first_move = true; // whether it's the first time to move the mouse

        var isTouchDevice = window.matchMedia('(hover: hover)');
        if (!isTouchDevice || isTouchDevice.matches) {
          console.log('not touch device');
          // mousedown on document
          TagCloud._on(document, 'mousedown', function () {
            self.active = true;
            console.log('active');
          });
          // mouseup on document
          TagCloud._on(document, 'mouseup', function () {
            self.active = false;
            self.last_mouseX = null;
            self.last_mouseY = null;
            self.first_move = true;
            console.log('inactive');
          });
          // mousemove on document
          TagCloud._on(self.keep ? window : document, 'mousemove', function (ev) {
            if (!self.active) return;
            ev = ev || window.event;
            var rect = self.$el.getBoundingClientRect();
            self.mouseX = (ev.clientX - (rect.left + rect.width / 2)) / 5;
            self.mouseY = (ev.clientY - (rect.top + rect.height / 2)) / 5;
          });
        } else { // for touch device
          console.log('touch device');
          // touchstart on document
          TagCloud._on(document, 'touchstart', function () {
            self.active = true;
            console.log('active');
          });
          // touchend on document
          TagCloud._on(document, 'touchend', function () {
            self.active = false;
            self.last_mouseX = null;
            self.last_mouseY = null;
            self.first_move = true;
            console.log('inactive');
          });
          // touchmove on document
          TagCloud._on(self.keep ? window : document, 'touchmove', function (ev) {
            if (!self.active) return;
            ev = ev || window.event;
            var rect = self.$el.getBoundingClientRect();
            self.mouseX = (ev.touches[0].clientX - (rect.left + rect.width / 2)) / 5;
            self.mouseY = (ev.touches[0].clientY - (rect.top + rect.height / 2)) / 5;
          });
        }

        // update state regularly
        self._next(); // init update state

        self.interval = self._requestInterval(function () {
          self._next.call(self);
        }, 10);
      } // calculate the next state

    }, {
      key: "_next",
      value: function _next() {
        var self = this;

        if (self.last_a == null || self.last_b == null) {
          self.last_a = -(Math.min(Math.max(-self.delta_mouseY, -self.size), self.size) / self.radius) * self.maxSpeed;
          self.last_b = Math.min(Math.max(-self.delta_mouseX, -self.size), self.size) / self.radius * self.maxSpeed;
        }

        var a, b;

        if (self.active || self.paused) {
          if (self.last_mouseX == null || self.last_mouseY == null) {
            self.last_mouseX = self.mouseX;
            self.last_mouseY = self.mouseY;
          }
          self.delta_mouseX = self.mouseX - self.last_mouseX;
          self.delta_mouseY = self.mouseY - self.last_mouseY;
          self.last_mouseX = self.mouseX;
          self.last_mouseY = self.mouseY;

          var active_drag_coe = 0.005;
          var delta_mouseX_applied, delta_mouseY_applied
          delta_mouseX_applied = self.delta_mouseX * active_drag_coe * self.radius;
          delta_mouseY_applied = self.delta_mouseY * active_drag_coe * self.radius;

          a = -Math.min(-delta_mouseY_applied, self.size);
          b = Math.min(-delta_mouseX_applied, self.size);
        } else {
          a = self.last_a;
          b = self.last_b;
        }

        if (Math.abs(a) <= 0.01 && Math.abs(b) <= 0.01) {
          console.log('stop');
          return;
        }

        if (self.first_move && self.active) {
          // the mouseX and mouseY will suddenly change when the mouse is first moved
          // thus abandon the first change, or the delta will be very large and incorrect
          self.first_move = false;
          return;
        }

        if (!self.active) {
          a = regularize(a, -self.maxSpeed, self.maxSpeed);
          b = regularize(b, -self.maxSpeed, self.maxSpeed);
        }

        self.last_a = a;
        self.last_b = b;

        // calculate offset
        var l = Math.PI / 180;
        var sc = [Math.sin(a * l), Math.cos(a * l), Math.sin(b * l), Math.cos(b * l)];
        self.items.forEach(function (item) {
          var rx1 = item.x;
          var ry1 = item.y * sc[1] + item.z * -sc[0];
          var rz1 = item.y * sc[0] + item.z * sc[1];
          var rx2 = rx1 * sc[3] + rz1 * sc[2];
          var ry2 = ry1;
          var rz2 = rz1 * sc[3] - rx1 * sc[2];
          var per = 2 * self.depth / (2 * self.depth + rz2); // todo

          item.x = rx2;
          item.y = ry2;
          item.z = rz2;
          item.scale = per.toFixed(3);
          var alpha = per * per - 0.25;
          alpha = sigmoid((alpha - 0.75) * 10);
          alpha *= 1.2;
          alpha = (alpha > 1 ? 1 : alpha).toFixed(3);
          var itemEl = item.el;
          var left = (item.x - itemEl.offsetWidth / 2).toFixed(2);
          var top = (item.y - itemEl.offsetHeight / 2).toFixed(2);
          var transform = "translate3d(".concat(left, "px, ").concat(top, "px, 0) scale(").concat(item.scale, ")");
          itemEl.style.WebkitTransform = transform;
          itemEl.style.MozTransform = transform;
          itemEl.style.OTransform = transform;
          itemEl.style.transform = transform;
          itemEl.style.filter = "alpha(opacity=".concat(100 * alpha, ")");
          itemEl.style.opacity = alpha;
        });
      }
      /* export instance properties and methods */
      // update

    }, {
      key: "update",
      value: function update(htmls) {
        var self = this; // params

        self.htmls = htmls || []; // judging and processing items based on htmls

        self.htmls.forEach(function (htmlCfg, index) {
          var item = self.items[index];

          var cfg = TagCloud._parseTagCfg(htmlCfg);

          var itemEl = self._createItemElement(cfg.html, index, cfg.mutator);

          if (!item) {
            item = _objectSpread2({
              el: itemEl
            }, self._computePosition(index, true));
            self.items.push(item);
          } else {
            // replace element when exists
            item.el.remove();
            item.el = itemEl;
          }

          self.$el.appendChild(item.el);
        }); // remove redundant self.items

        var htmlsLength = self.htmls.length;
        var itemsLength = self.items.length;

        if (htmlsLength < itemsLength) {
          var removeList = self.items.splice(htmlsLength, itemsLength - htmlsLength);
          removeList.forEach(function (item) {
            self.$el.removeChild(item.el);
          });
        }
      } // destroy

    }, {
      key: "destroy",
      value: function destroy() {
        var self = this;
        self.interval = null; // clear in TagCloud.list

        var index = TagCloud.list.findIndex(function (e) {
          return e.el === self.$el;
        });
        if (index !== -1) TagCloud.list.splice(index, 1); // clear element

        if (self.$container && self.$el) {
          self.$container.removeChild(self.$el);
        }
      }
    }, {
      key: "pause",
      value: function pause() {
        var self = this;
        self.paused = true;
      }
    }, {
      key: "resume",
      value: function resume() {
        var self = this;
        self.paused = false;
      }
    }], [{
      key: "_on",
      value: // event listener
        function _on(el, ev, handler, cap) {
          if (el.addEventListener) {
            el.addEventListener(ev, handler, cap);
          } else if (el.attachEvent) {
            el.attachEvent("on".concat(ev), handler);
          } else {
            el["on".concat(ev)] = handler;
          }
        }
    }, {
      key: "_parseTagCfg",
      value: function _parseTagCfg(cfg) {
        return Array.isArray(cfg) ? {
          html: cfg[0],
          mutator: cfg[1]
        } : {
          html: cfg,
          mutator: null
        };
      }
    }]);

    return TagCloud;
  }();

  TagCloud.list = [];
  TagCloud._defaultConfig = {
    radius: 500,
    // rolling radius, unit `px`
    maxSpeed: 'slow',
    // rolling max speed, optional: `slow`, `normal`(default), `fast`
    initSpeed: 'fast',
    // rolling init speed, optional: `slow`, `normal`(default), `fast`
    direction: 135,
    // rolling init direction, unit clockwise `deg`, optional: `0`(top) , `90`(left), `135`(right-bottom)(default)...
    keep: true,
    // whether to keep rolling after mouse out area, optional: `false`, `true`(default)(decelerate to rolling init speed, and keep rolling with mouse)
    useContainerInlineStyles: true,
    useItemInlineStyles: true,
    containerClass: 'tagcloud',
    itemClass: 'tagcloud--item'
  };

  TagCloud._getMaxSpeed = function (name) {
    return {
      slow: 0.2,
      normal: 1,
      fast: 2
    }[name] || 1;
  };

  TagCloud._getInitSpeed = function (name) {
    return {
      slow: 16,
      normal: 32,
      fast: 300
    }[name] || 32;
  };

  var index = (function (els, htmls, options) {
    if (typeof els === 'string') els = document.querySelectorAll(els);
    if (!els.forEach) els = [els];
    var instances = [];
    els.forEach(function (el) {
      if (el) {
        instances.push(new TagCloud(el, htmls, options));
      }
    });
    return instances.length <= 1 ? instances[0] : instances;
  });

  return index;

})));