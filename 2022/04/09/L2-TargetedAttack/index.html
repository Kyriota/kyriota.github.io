<!DOCTYPE HTML>
<html>
<head>
  <!-- analytics -->
  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-72YBP3VHKR"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-72YBP3VHKR');
  </script>
  
  
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>L2 Targeted Attack | KYRIOTA</title>
  <meta name="author" content="KYRIOTA">
  
  <meta name="description" content="终于是把这玩意儿自己实现了一遍，恰逢miniL CTF，这文章虽然是22.04.09写的，但是估计博客得等到五月多才会更新，届时将也再补充一些在miniL CTF中本题的情况">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="L2 Targeted Attack"/>
  <meta property="og:site_name" content="KYRIOTA"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/img/icon.ico" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="KYRIOTA" type="application/atom+xml">
</head>
 <body>
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Home</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the blogs.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="Sort by categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About Kyriota">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/html/meme" title="Ingredients that compose me">
			  <i class=""></i>Meme
			</a>
		  </li>
		  
		  <li>
			<a href="/html/academic" title="Academic Home">
			  <i class=""></i>Academic
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> L2 Targeted Attack</h1>
		</div>
	



    <div class="row post">
        <!-- cols -->
        
            <div id="top_meta"></div>
            <div class="col-md-9">
                

                            <!-- content -->
                            <div class="mypage">
                                

                                        <p>终于是把这玩意儿自己实现了一遍，恰逢miniL CTF，这文章虽然是22.04.09写的，但是估计博客得等到五月多才会更新，届时将也再补充一些在miniL CTF中本题的情况</p>
<span id="more"></span>
<h1 id="l2-targeted-attack">L2 Targeted Attack</h1>
<p><strong>前置知识：<a target="_blank" rel="noopener" href="https://kyriota.com/2022/01/16/%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%5D/">全连接神经网络</a></strong></p>
<p><strong>参考文献：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1608.04644">Towards Evaluating the Robustness</a></strong></p>
<blockquote>
<p>碎碎念：这段时间又在捣鼓<a target="_blank" rel="noopener" href="https://kyriota.com/2021/11/17/Uncertainty/">Uncertainty</a>，加点内容想去参加吉比特的Jam，等Jam完了可能的研究对象应该是CNN，UE5之类的（神经细胞自动机暂时就先鸽了，但确实很有趣，以后应该回去看看的</p>
</blockquote>
<h2 id="minil-ctf">miniL CTF</h2>
<p>有幸在校内的miniL CTF出一次题（一个L2TargetedAttack，一个CheatEngine改坐标），本来想做一个CNN的L2 Targeted Attack，这样可以把情景包装得有趣一些，但是还是太懒了，弄完这个就不想弄CNN了，就先出到这里了</p>
<p>题目名为<code>NEXT</code>，顾名思义就是让你对MNIST中的几个Samples加扰动，使得如下的8个Samples被模型识别成其原本lable的下一个数，如1→2，2→3...</p>
<p>为了让题目有个情景，所以把原本的weight给轮了一下顺序，原lable本应是[0,1,2,3,4,5,6,7,8,9]，被改成了[1,2,3,4,5,6,7,8,9,0]，于是乎题目就有了一个虽然不合理但可以忽悠人的情景</p>
<p><img src="/images/L2TarAtt_Original.png"></p>
<p>模型为带DropOut的FCNN，虽然带DropOut，但是整体梯度比较明显，对扰动的鲁棒性欠佳，很适合作为攻击对象</p>
<p>源码上对原本的函数做了一点混淆，比如<code>softMax</code>缩写成<code>SM</code>之类的，主要是为了选手深入了解神经网络之后再入手题目，不要底层没摸清楚做纯纯的TFboy</p>
<p>限制了L2和Linf的大小，是为了让做题人明确这是一个L2 Attack</p>
<p>task中不包含<code>torch</code>，<code>TF</code>之类的，但可以把weight手动导入一下，然后使用如<code>tf.gradientTape</code>之类的方法自动求梯度，我自己解是用比较土的手搓<code>BackProp</code></p>
<p><a target="_blank" rel="noopener" href="https://kyriota.com/html/DLfiles/NEXT_ALL.zip">下载题目及exp</a></p>
<p>以下是题目代码</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        task.py
    </div>
    <div class='spoiler-content'>
        <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf8 -</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">L2CONSTRAIN = <span class="number">5.6789</span></span><br><span class="line">LINFCONSTRAIN = <span class="number">1.234</span></span><br><span class="line">CONFIDENCE = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RL</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.maximum(x, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SM</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.array(np.exp(x) / np.<span class="built_in">sum</span>(np.exp(x), axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AB</span>(<span class="params">x</span>):</span></span><br><span class="line">    x = np.matrix(x)</span><br><span class="line">    <span class="keyword">return</span> np.c_[np.ones((x.shape[<span class="number">0</span>], <span class="number">1</span>)), x]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ANN</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, uNum</span>):</span></span><br><span class="line">        self.uNum = uNum</span><br><span class="line">        self.lNum = <span class="built_in">len</span>(uNum)</span><br><span class="line">        self.w = [<span class="number">0</span>]</span><br><span class="line">        self.Z = [<span class="number">0</span>]</span><br><span class="line">        self.A = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FP</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, self.lNum - <span class="number">1</span>):</span><br><span class="line">            self.Z.append(AB(self.A[-<span class="number">1</span>]) * self.w[i])</span><br><span class="line">            self.A.append(RL(self.Z[-<span class="number">1</span>]))</span><br><span class="line">        self.Z.append(AB(self.A[-<span class="number">1</span>]) * self.w[-<span class="number">1</span>])</span><br><span class="line">        self.A.append(SM(self.Z[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PRED</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.Z[<span class="number">0</span>] = np.matrix(x)</span><br><span class="line">        self.A[<span class="number">0</span>] = np.matrix(x)</span><br><span class="line">        self.FP()</span><br><span class="line">        <span class="keyword">return</span> np.array(self.A[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LOAD</span>(<span class="params">self, fileName</span>):</span></span><br><span class="line">        f = <span class="built_in">open</span>(fileName, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">        wt = np.frombuffer(f.read(), np.float64)</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(self.uNum)):</span><br><span class="line">            data = wt[: (self.uNum[i - <span class="number">1</span>] + <span class="number">1</span>) * self.uNum[i]]</span><br><span class="line">            shape = (self.uNum[i - <span class="number">1</span>] + <span class="number">1</span>, self.uNum[i])</span><br><span class="line">            self.w.append(np.matrix(data).reshape(shape))</span><br><span class="line">            wt = wt[(self.uNum[i - <span class="number">1</span>] + <span class="number">1</span>) * self.uNum[i]:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CHECK</span>(<span class="params">mask: np.matrix, myNN: ANN, x</span>):</span></span><br><span class="line">    l2 = np.<span class="built_in">sum</span>(np.linalg.norm(np.array(mask), axis=<span class="number">1</span>)) / <span class="number">8</span></span><br><span class="line">    linf = np.<span class="built_in">max</span>(np.linalg.norm(np.array(mask), <span class="built_in">ord</span>=np.inf, axis=<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> l2 &gt; L2CONSTRAIN:</span><br><span class="line">        print(<span class="string">&quot;Huge L2 &quot;</span> + <span class="built_in">str</span>(l2))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> linf &gt; LINFCONSTRAIN:</span><br><span class="line">        print(<span class="string">&quot;Huge Linf&quot;</span> + <span class="built_in">str</span>(linf))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    res = myNN.PRED(x + mask)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        lable = np.argmax(res[i])</span><br><span class="line">        <span class="keyword">if</span> lable != i + <span class="number">1</span>:</span><br><span class="line">            print(<span class="string">&quot;Wrong Lable &quot;</span> + <span class="built_in">str</span>(lable) + <span class="string">&quot;, &quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> res[i][lable] &lt; CONFIDENCE:</span><br><span class="line">            print(<span class="string">&quot;Unconfident &quot;</span> + <span class="built_in">str</span>(lable) + <span class="string">&quot;, &quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot;, &quot;</span> + <span class="built_in">str</span>(res[i][lable]))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    print(flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    uNum = [<span class="number">784</span>, <span class="number">512</span>, <span class="number">256</span>, <span class="number">10</span>]</span><br><span class="line">    myNN = ANN(uNum)</span><br><span class="line">    myNN.LOAD(<span class="string">&quot;weight.dat&quot;</span>)</span><br><span class="line">    data = pd.read_csv(<span class="string">r&#x27;picData.csv&#x27;</span>)</span><br><span class="line">    x = np.matrix(data.iloc[:, <span class="number">1</span>:])</span><br><span class="line">    mask = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        print(<span class="string">&quot;&gt;&gt; Mask &quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot; :&quot;</span>)</span><br><span class="line">        maskTemp = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">784</span>):</span><br><span class="line">            maskTemp.append(<span class="built_in">float</span>(<span class="built_in">input</span>()))</span><br><span class="line">        mask.append(np.array(maskTemp, dtype=np.float64).ravel())</span><br><span class="line">    mask = np.matrix(mask)</span><br><span class="line">    CHECK(mask, myNN, x)</span><br></pre></td></tr></table></figure>

    </div>
</div>
<h2 id="attack">Attack</h2>
<h3 id="loss">Loss</h3>
<p>参考论文，在<code>Loss</code>中包含了对L2的惩罚项，我implement的时候使用的是类似于参数正则化一样的方法，简单但有效，在每次迭代后：根据对L2的限制，让最终的噪声<code>Pert</code>自减一点点</p>
<p>而对于如何在<code>Loss</code>中体现出逼近Target，直接借鉴一下Carlini大神的结论，即参考文献中的<code>f6</code>，毕竟这些东西就是凭经验凭感觉弄出来的，他们基本也就是选了一些自己觉得有可能可行的<code>Loss</code>然后全部跑一遍，找一个效果最好的</p>
<p><img src="/images/L2TarAtt_f6.png" width=350></p>
<p>其中加号上标表示对括号内的参数<code>x</code>执行<code>max(x, 0)</code></p>
<p>大概意会一下，首先这玩意儿得从<code>logits</code>层开始回归，然后至于他这个<code>Loss</code>的思想也就字面意思：打压当前概率最高的，同时扶持target的概率</p>
<p>我没有完全按照他的<code>loss</code>来（主要是为了方便），但是思想都是一样的，我implement的就是一个对无关项置零的交叉熵，代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d_crossEntPert</span>(<span class="params">self</span>):</span></span><br><span class="line">    mat = np.matrix(self.A[-<span class="number">1</span>] - self.y)</span><br><span class="line">    <span class="keyword">if</span> np.argmax(np.array(self.y).ravel()) != np.argmax(np.array(self.A[-<span class="number">1</span>]).ravel()):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> i != np.argmax(np.array(self.y).ravel()) <span class="keyword">and</span> i != np.argmax(np.array(self.A[-<span class="number">1</span>]).ravel()):</span><br><span class="line">                mat[<span class="number">0</span>, i] = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> mat</span><br></pre></td></tr></table></figure>
<p>注1：此处的<code>Loss</code>还并非最终形态，因为没有加入对<code>Pert</code>的惩罚项</p>
<p>注2：关于为什么要在最终label是target的情况下直接return，则是因为这样在已经找到属于target的决策区域后的下降速度更快，还可以防止梯度消失</p>
<h3 id="get-gradient">Get Gradient</h3>
<p>由于是自己搓的FCNN，获取梯度直接<code>backProp</code>就行了，比如想要倒数第二层的dZ，<code>backProp</code>之后就直接<code>FCNN.dZ[-2]</code>，非常方便，这个手搓<code>BP</code>的梯度也拿去和<code>tensorflow</code>中的<code>gradientTape</code>求出的梯度做了对比，保证梯度正确</p>
<p>简化剔除了一些常规<code>BP</code>在此情境下不需要的内容，得到以下代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backProp</span>(<span class="params">self, d_lossFunc</span>):</span></span><br><span class="line">    self.dZ[-<span class="number">1</span>] = d_lossFunc()</span><br><span class="line">    dw = self.A[-<span class="number">2</span>].T * self.dZ[-<span class="number">1</span>]</span><br><span class="line">    db = np.<span class="built_in">sum</span>(self.dZ[-<span class="number">1</span>], axis=<span class="number">0</span>)</span><br><span class="line">    self.dw[-<span class="number">1</span>] = np.r_[db, dw]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, self.layerNum - <span class="number">1</span>)):</span><br><span class="line">        self.dA[i] = RemoveBias(self.dZ[i + <span class="number">1</span>] * self.w[i + <span class="number">1</span>].T)</span><br><span class="line">        self.dZ[i] = np.multiply(d_relu(self.Z[i]), self.dA[i])</span><br><span class="line">        dw = self.A[i - <span class="number">1</span>].T * self.dZ[i]</span><br><span class="line">        db = np.<span class="built_in">sum</span>(self.dZ[i], axis=<span class="number">0</span>)</span><br><span class="line">        self.dw[i] = np.r_[db, dw]</span><br><span class="line">	self.dA[<span class="number">0</span>] = RemoveBias(self.dZ[<span class="number">1</span>] * self.w[<span class="number">1</span>].T)</span><br><span class="line">	self.dZ[<span class="number">0</span>] = self.dA[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="fool">Fool</h3>
<p>现在关键成分都已经齐全了，就可以开始生成AdversarialPerturbation了</p>
<p>基本的迭代过程大致如下：</p>
<ul>
<li>把target设置成<code>y</code>，因为<code>loss</code>函数中会用到（比如要把<code>6</code>糊弄成<code>7</code>，则<code>target=7</code>）</li>
<li>ForwardProp()</li>
<li>判断target的confidence是否符合要求，符合则return，不符合则继续</li>
<li>BackProp()</li>
<li>对梯度加入关于<code>Pert</code>的惩罚项</li>
</ul>
<p>在此基础上，还进行了几点优化：</p>
<ul>
<li>因为这个方法肉眼可见的容易出现惩罚项与逼近Target的方向相反的情况，所以加入了一个在Stuck时进行随机扰动的功能</li>
<li>对起点进行比较小的随机扰动，稍微差异化每次下降过程</li>
</ul>
<p>（在输出中加emoji主要是为了快速浏览运行结果，而且事实证明Jupyter对此支持是没问题的，看着很直观</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, myNetwork</span>):</span></span><br><span class="line">        self.Network = myNetwork</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetGrad</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        pred = self.Network.predict(X)</span><br><span class="line">        self.Network.backProp(self.Network.d_crossEntPert)</span><br><span class="line">        <span class="keyword">return</span> self.Network.dA[<span class="number">0</span>], pred.ravel()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fool</span>(<span class="params">self, X, y, tar, foolRate=<span class="number">0.5</span>, maxIter=<span class="number">500</span>, step=<span class="number">0.05</span>, minGrad=<span class="number">0.05</span>, maxGrad=<span class="number">10</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             constrain=<span class="number">10</span>, stuckRandL2=<span class="number">1</span>, initRandL2=<span class="number">1</span></span>):</span></span><br><span class="line">        rand = np.matrix(np.random.randn(<span class="number">1</span>, <span class="number">784</span>))</span><br><span class="line">        pert = np.zeros((<span class="number">1</span>, <span class="number">784</span>)) + initRandL2 * rand / np.linalg.norm(rand)</span><br><span class="line">        loss = []</span><br><span class="line">        L2Rec = []</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        stuckCnt = <span class="number">0</span></span><br><span class="line">        stuckJudgeCnt = <span class="number">0</span></span><br><span class="line">        success = <span class="literal">False</span></span><br><span class="line">        self.Network.predict(X + pert)</span><br><span class="line">        print(<span class="string">&quot;init: &quot;</span> + <span class="built_in">str</span>(y) + <span class="string">&quot; prob: &quot;</span> +</span><br><span class="line">              <span class="built_in">str</span>(self.Network.A[-<span class="number">1</span>].ravel()[y]))</span><br><span class="line">        self.Network.y = OneHot(</span><br><span class="line">            <span class="number">1</span>, self.Network.unitNum[-<span class="number">1</span>], y) <span class="keyword">if</span> tar == -<span class="number">1</span> <span class="keyword">else</span> OneHot(<span class="number">1</span>, self.Network.unitNum[-<span class="number">1</span>], tar)</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            print(<span class="string">&quot;\rcnt: &quot;</span> + <span class="built_in">str</span>(cnt) + <span class="string">&quot;  stuck: &quot;</span> + <span class="built_in">str</span>(stuckCnt), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            grad, pred = self.GetGrad(X + pert)</span><br><span class="line">            loss.append(np.linalg.norm(self.Network.A[-<span class="number">1</span>]) <span class="keyword">if</span> tar == -<span class="number">1</span> <span class="keyword">else</span></span><br><span class="line">                        -np.<span class="built_in">sum</span>(np.array(self.Network.y) * np.log(self.Network.A[-<span class="number">1</span>])</span><br><span class="line">                        + np.array(<span class="number">1</span> - self.Network.y) * np.log(<span class="number">1</span> - self.Network.A[-<span class="number">1</span>])))</span><br><span class="line">            <span class="keyword">if</span> ((self.Network.A[-<span class="number">1</span>].ravel()[y] &lt; foolRate <span class="keyword">if</span> tar == -<span class="number">1</span> <span class="keyword">else</span> self.Network.A[-<span class="number">1</span>].ravel()[tar] &gt; foolRate)</span><br><span class="line">                    <span class="keyword">and</span> stuckJudgeCnt &gt; <span class="number">5</span>):</span><br><span class="line">                print(<span class="string">&quot;\n⭕ OK:      &quot;</span> + <span class="built_in">str</span>(np.argmax(pred)) + <span class="string">&quot;    &quot;</span> +</span><br><span class="line">                      <span class="built_in">str</span>(self.Network.A[-<span class="number">1</span>].ravel()[np.argmax(pred)]) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                success = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> np.linalg.norm(pert):</span><br><span class="line">                para = <span class="built_in">max</span>((np.linalg.norm(pert) - constrain) ** <span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">                grad -= np.<span class="built_in">sum</span>(np.array(pert) * np.array(grad)) * \</span><br><span class="line">                    (pert / np.linalg.norm(pert)) * para</span><br><span class="line">            L2 = np.linalg.norm(grad)</span><br><span class="line">            L2Rec.append(np.array(L2).ravel())</span><br><span class="line">            <span class="keyword">if</span> L2 &gt; maxGrad:</span><br><span class="line">                grad *= maxGrad / L2</span><br><span class="line">            <span class="keyword">if</span> L2 &lt; minGrad:</span><br><span class="line">                <span class="keyword">if</span> L2 == <span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">&quot;\nERR: grad is zero&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                grad *= minGrad / L2</span><br><span class="line">            pert -= grad * step</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == maxIter - <span class="number">1</span>:</span><br><span class="line">                print(<span class="string">&quot;\n❌ nope:   &quot;</span> + <span class="built_in">str</span>(y <span class="keyword">if</span> tar == -<span class="number">1</span> <span class="keyword">else</span> tar) + <span class="string">&quot;      &quot;</span> +</span><br><span class="line">                      <span class="built_in">str</span>(self.Network.A[-<span class="number">1</span>].ravel()[y <span class="keyword">if</span> tar == -<span class="number">1</span> <span class="keyword">else</span> tar]) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> cnt &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">abs</span>(loss[-<span class="number">1</span>] - loss[-<span class="number">2</span>]) &lt; <span class="number">0.1</span>:</span><br><span class="line">                stuckJudgeCnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> stuckJudgeCnt &gt; <span class="number">10</span>:</span><br><span class="line">                    rand = np.matrix(np.random.randn(</span><br><span class="line">                        pert.shape[<span class="number">0</span>], pert.shape[<span class="number">1</span>]))</span><br><span class="line">                    pert += rand / np.linalg.norm(rand) * stuckRandL2</span><br><span class="line">                    stuckJudgeCnt = <span class="number">0</span></span><br><span class="line">                    stuckCnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> success, pert, loss, L2Rec</span><br></pre></td></tr></table></figure>
<h3 id="exp">Exp</h3>
<p>于是我们只需要基于以上的基础再对每个数字计算一遍即可</p>
<p>考虑到要使得L2尽可能小，我使用动态的Constrain，使得搜索结果的L2快速减小到一个可观的范围</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> KyNetExp</span><br><span class="line">X = np.matrix(pd.read_csv(<span class="string">r&#x27;picData.csv&#x27;</span>).iloc[:, <span class="number">1</span>:])</span><br><span class="line">unitNum = [<span class="number">784</span>, <span class="number">512</span>, <span class="number">256</span>, <span class="number">10</span>]</span><br><span class="line">FCNN = KyNetExp.Network()</span><br><span class="line">FCNN.Init(unitNum)</span><br><span class="line">FCNN.LoadParameters(<span class="string">&quot;weight.dat&quot;</span>)</span><br><span class="line">Fool = KyNetExp.Fool(FCNN)</span><br><span class="line">pert = []</span><br><span class="line">deltaConstrain = <span class="number">0.1</span></span><br><span class="line">maxUnsuccessCnt = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    print(<span class="string">&quot;\n-------------------- &quot;</span> + <span class="built_in">str</span>(i + <span class="number">1</span>) + <span class="string">&quot; --------------------\n&quot;</span>)</span><br><span class="line">    bestPert = np.matrix(np.ones((<span class="number">1</span>,<span class="number">784</span>)) * np.inf)</span><br><span class="line">    constrain = <span class="number">30</span></span><br><span class="line">    UnsuccessCnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(UnsuccessCnt &lt; maxUnsuccessCnt):</span><br><span class="line">        success = <span class="literal">False</span></span><br><span class="line">        success, pert_i, loss, L2Rec = Fool.Fool(X[i], i+<span class="number">1</span>, i+<span class="number">2</span>, maxIter=<span class="number">500</span>, foolRate=<span class="number">0.8</span>,</span><br><span class="line">                                                 constrain=constrain, stuckRandL2=<span class="number">1</span>, initRandL2=<span class="number">1</span>,</span><br><span class="line">                                                 minGrad=<span class="number">0.001</span>)</span><br><span class="line">        <span class="keyword">if</span> success:</span><br><span class="line">            <span class="keyword">if</span> np.linalg.norm(pert_i) &lt; np.linalg.norm(bestPert):</span><br><span class="line">                constrain = <span class="built_in">min</span>(np.linalg.norm(pert_i) - deltaConstrain, constrain)</span><br><span class="line">                bestPert = pert_i</span><br><span class="line">                UnsuccessCnt = <span class="number">0</span></span><br><span class="line">                print(<span class="string">&quot;----------------------------------&quot;</span>)</span><br><span class="line">                print(<span class="string">&quot;# New Constrain: &quot;</span> + <span class="built_in">str</span>(constrain))</span><br><span class="line">                print(<span class="string">&quot;----------------------------------\n&quot;</span>)</span><br><span class="line">            constrain -= deltaConstrain / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            UnsuccessCnt += <span class="number">1</span></span><br><span class="line">    pert.append(bestPert)</span><br></pre></td></tr></table></figure>
<p>最终生成的Pert数据如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># L2</span></span><br><span class="line">np.linalg.norm(np.array([np.array(i).ravel() <span class="keyword">for</span> i <span class="keyword">in</span> pert]), axis=<span class="number">1</span>)</span><br><span class="line">&gt;&gt; array([<span class="number">4.09481434</span>, <span class="number">4.2946097</span> , <span class="number">6.64396102</span>, <span class="number">5.90332629</span>, <span class="number">6.05583615</span>,</span><br><span class="line">       <span class="number">5.71162228</span>, <span class="number">6.26226203</span>, <span class="number">3.06447416</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值</span></span><br><span class="line">np.<span class="built_in">sum</span>(np.linalg.norm(np.array([np.array(i).ravel() <span class="keyword">for</span> i <span class="keyword">in</span> pert]), axis=<span class="number">1</span>)) / <span class="number">8</span></span><br><span class="line">&gt;&gt; <span class="number">5.2538632468131485</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Linf</span></span><br><span class="line">np.linalg.norm(np.array([np.array(i).ravel() <span class="keyword">for</span> i <span class="keyword">in</span> pert]), <span class="built_in">ord</span>=np.inf, axis=<span class="number">1</span>)</span><br><span class="line">&gt;&gt; array([<span class="number">0.51915417</span>, <span class="number">0.6969855</span> , <span class="number">0.94458608</span>, <span class="number">0.8020708</span> , <span class="number">0.99483219</span>,</span><br><span class="line">       <span class="number">0.70698208</span>, <span class="number">1.12368025</span>, <span class="number">0.41853863</span>])</span><br></pre></td></tr></table></figure>
<p>宏观感受如下</p>
<p><img src="/images/L2TarAtt_Attacked.png"></p>
<p>对比Carlini的论文中的L2数据，我认为这样的结果勉强可以接受，但鉴于视觉效果仍然不佳，之后可能会考虑在更大规模的model和dataset上做adversarial attack方面的种种实验</p>
<h2 id="dumbass">DumbAss</h2>
<p>一开始还想着靠单纯的梯度下降直接，硬着提高target的自信度，但是导致的问题就是各种梯度消失梯度过缓之类的，比如我当时的<code>loss</code>是这样下降的</p>
<p><img src="/images/L2TarAtt_fig.png"></p>
<p>具体是把<code>6</code>识别成<code>7</code>的情景，范数如下，吃力不讨好了属于是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L2  : <span class="number">8.161735079209715</span></span><br><span class="line">Linf: <span class="number">1.188402119264267</span></span><br></pre></td></tr></table></figure>
<p>在做这个L2 Targeted Attack的时候，最多的时间应该是浪费在以下这几件事上：</p>
<ul>
<li><code>float64</code>与<code>float32</code>在加载与储存的时候没有注意类型，导致不能及时与<code>tensorFlow</code>对答案</li>
<li><code>softMax</code>偏导的函数错误，导致最终偏导错误</li>
<li>文献查找，找到Carlini的这篇文章花了挺多时间的</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
                            </div>

                            <div>
                                <center>
                                    <div class="pagination">

    
    
    <a href="/2022/06/03/FriendLinksSetup/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2022/03/23/HandleCrack/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

                                </center>
                            </div>

                            <!-- comment -->
                            
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>


                    </div>
                    <!-- col-md-9/col-md-12 -->

                    
                        <div id="side_meta">
                            <div class="col-md-3" id="post_meta">

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2022-04-09
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/AI/">AI<span>5</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>
    <ul id="tags" class="tag_box list-unstyled collapse in">
	    
  <li><a href="/tags/CTF/">CTF<span>7</span></a></li>
    </ul>
	</div>
	

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#l2-targeted-attack"><span class="toc-article-text">L2 Targeted Attack</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#minil-ctf"><span class="toc-article-text">miniL CTF</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#attack"><span class="toc-article-text">Attack</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#loss"><span class="toc-article-text">Loss</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#get-gradient"><span class="toc-article-text">Get Gradient</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#fool"><span class="toc-article-text">Fool</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#exp"><span class="toc-article-text">Exp</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#dumbass"><span class="toc-article-text">DumbAss</span></a></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

                        </div>
                        

            </div>
            <!-- row -->
            


                
                    <div id="gitalk-container"></div>
                    <link rel="stylesheet" href="/css/gitalk.css">
<script src="/js/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<script type="text/javascript">
    new Gitalk({
        clientID: '91155bbf0d150664c4e8',
        clientSecret: 'a6ace36b45921480fe64e5a8d76de241d197bb15',
        repo: 'kyriota.github.io',
        owner: 'Kyriota',
        admin: 'Kyriota',
        id: md5(location.pathname),
        createIssueManually: true,
        distractionFreeMode: true
    }).render('gitalk-container')
</script>
                        
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
    
        &copy;
        2024
            KYRIOTA
                
                                Powered By <a href="http://hexo.io/" target="_blank">Hexo</a>, Modified From <a target="_blank" rel="noopener" href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.
</p> </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
